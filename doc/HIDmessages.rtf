{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f28\froman\fcharset238\fprq2 Times New Roman CE;}{\f29\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f31\froman\fcharset161\fprq2 Times New Roman Greek;}{\f32\froman\fcharset162\fprq2 Times New Roman Tur;}
{\f33\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f34\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f35\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f36\fswiss\fcharset238\fprq2 Arial CE;}{\f37\fswiss\fcharset204\fprq2 Arial Cyr;}
{\f39\fswiss\fcharset161\fprq2 Arial Greek;}{\f40\fswiss\fcharset162\fprq2 Arial Tur;}{\f41\fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f42\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f43\fswiss\fcharset186\fprq2 Arial Baltic;}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;
\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}}{\info{\author Csern\'e1th G\'e9za}{\operator Csern\'e1th G\'e9za}{\creatim\yr2006\mo4\dy13\hr12\min53}{\revtim\yr2006\mo4\dy13\hr13\min4}
{\version2}{\edmins11}{\nofpages5}{\nofwords1234}{\nofchars7039}{\nofcharsws8644}{\vern8247}}\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0
\dgvshow3\jcompress\viewkind1\viewscale100\nolnhtadjtbl \fet0\sectd \linex0\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3
\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}
{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain 
\qc \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1\fs28\ul HID DEVICE MESSAGES}{\b\f1\fs20 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\i\f1\fs20 NOTE: 
\par \tab The values are in hexadecimal (Exp. 0x11)
\par \tab All type of messages have in the first byte the message type. After the message type is the message content. The }{\i\f1\fs20\ul meaning}{\i\f1\fs20 
 entry of the description always deals with the message content (first byte and byte 0 means, first byte from the content).
\par 
\par }{\i\f1\fs20\ul ERROR MESSAGES (*)}{\i\f1\fs20  (received only as response for OUTPUT messages):
\par RESULT_PARAMETER_MISSING\tab 0x01 // Request does not contain all necessary parameters (request is too short, no length or no address either).
\par RESULT_DATA_MISSING\tab \tab 0x02 // Request attempts to write more data than was actually sent.
\par RESULT_BLOCK_READ_ONLY\tab 0x03 // Request attempts to erase or write a block within the flasher code section.
\par RESULT_BLOCK_NOT_ERASABLE\tab 0x04 // Request attempts to erase a block outside of "erasable" memory space.
\par RESULT_BLOCK_TOO_BIG \tab \tab 0x05 // Request attempts to access more data at once than the HID buffer can handle.
\par RESULT_SECTION_OVERFLOW\tab 0x06 // Request (address & length) attempts to cross over a section boundary (section boundaries are set at 1Mbyte boundaries -> 0x100000, 0x200000... etc.).
\par }{\b\f1\fs20 
\par }\pard \qc \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\b\f1\fs20\ul MESSAGE DESCRIPTION}{\b\f1\fs20 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\b\f1\fs20 KEYBOARD MODE: INPUT}{\f1\fs20 
\par 
\par }{\f1\fs20\ul IN_REPORT_POWER_STATE\tab \tab \tab 0x01}{\f1\fs20 
\par \tab -POWER key was pressed
\par \tab -length: 1 byte (INPUT)
\par \tab -meaning:\tab a) at keypress the value is alwyas 1
\par \tab \tab \tab b) on Windows OS this message is used by the OS (not included in the HIDDaemon)
\par 
\par }{\f1\fs20\ul IN_REPORT_KEY_STATE\tab \tab \tab 0x11}{\f1\fs20 
\par \tab -key pressed
\par \tab -length: 2 byte (INPUT)
\par \tab -range: 0x00...0x0E
\par \tab -meaning:\tab a) maximum two keypresses in the same time are accepted
\par \tab \tab \tab b) nothing is pressed: 0x00, 0x00
\par \tab \tab \tab c) one or two keys was pressed: the two values are represnting the two keys
\par \tab \tab \tab d) three or more keys pressed: 0x00, 0x00
\par 
\par }{\f1\fs20\ul IN_REPORT_IR_DATA\tab \tab \tab \tab 0x21}{\f1\fs20 
\par \tab -infrared message 
\par \tab -length: 1+maximum 20 byte (INPUT)
\par \tab -meaning:\tab a) first byte representing the length of the IR message (0x00...0x14)
\par \tab \tab \tab b) IR message is fllowing the length: two bytes are represnting one int 
\par 
\par }{\b\f1\fs20 KEYBOARD MODE: OUTPUT
\par }{\f1\fs20 
\par }{\f1\fs20\ul OUT_REPORT_LED_STATE\tab \tab \tab 0x81}{\f1\fs20 
\par \tab -setting the status of the LED's
\par \tab -length: 1 byte (OUTPUT)
\par \tab -range: 0x00...0xFF
\par \tab -meaning:\tab a) bit set to "1" switches the LED to ON
\par \tab \tab \tab b) bit set to "0" switches the LED to OFF
\par \tab \tab \tab (every bit is representing one LED)
\par 
\par }{\f1\fs20\ul OUT_REPORT_LCD_BACKLIGHT\tab \tab 0x91
\par }{\f1\fs20 \tab -LCD bakclight on/off
\par \tab -length: 1 byte (OUTPUT)
\par \tab -range: 0x00...0xFF
\par \tab -meaning:\tab a) 0x00 - Backlight OFF
\par \tab \tab \tab b) 0x01...0xFF - Backlight ON
\par 
\par }{\f1\fs20\ul OUT_REPORT_LCD_CONTRAST\tab \tab 0x92}{\f1\fs20 
\par \tab -LCD contrast
\par \tab -length: 1 byte (OUTPUT)
\par \tab -range: 0x00...0x40
\par \tab -meaning:\tab a) 0x00 means MAXIMUM contrast/0x40 means MINIMUM contrast
\par 
\par }{\f1\fs20\ul OUT_REPORT_LCD_CONTROL\tab \tab \tab 0x93}{\f1\fs20 
\par \tab -LCD working mode 
\par \tab -length: 1 byte (OUTPUT)
\par \tab -range: 0x00...0x07
\par \tab -meaning:\tab a) bit 0: cursor blinking (BLINK) ON("1")/OFF("0")
\par \tab \tab \tab b) bit 1: cursor switch ON("1")/OFF("0")
\par \tab \tab \tab c) bit 2: LCD switch ON("1")/OFF("0")
\par 
\par }{\f1\fs20\ul OUT_REPORT_LCD_CLEAR\tab \tab \tab 0x94}{\f1\fs20 
\par \tab -LCD screen clear
\par \tab -length: 0 byte (OUTPUT)
\par 
\par }{\f1\fs20\ul OUT_REPORT_LCD_TEXT\tab \tab \tab 0x98}{\f1\fs20 
\par \tab -LCD write text
\par \tab -length: 3+20 byte (OUTPUT)
\par \tab -meaning:\tab a) first byte: ROW (0x00...0x01)
\par \tab \tab \tab b) second byte: COLUMN (0x00...0x14)
\par \tab \tab \tab c) third byte: STRING LENGTH (0x00...0x14)
\par \tab \tab \tab d) STRING  - maximum 20 chars, reduced ASCII (see the LCD ASCII table)
\par 
\par }{\f1\fs20\ul OUT_REPORT_LCD_FONT\tab \tab \tab 0x9C}{\f1\fs20 
\par \tab -LCD font change (for the first 8 characters only which can be rewritten dinamically)
\par \tab -length: 1+8 byte (OUTPUT)
\par \tab -meaning:\tab a) first byte: CHAR NUMBER (0x00...0x07)
\par \tab \tab \tab b) BITMAP of the new char (8*5 dots in 8 bytes, every byte holding row in the lower bits)
\par 
\par }{\f1\fs20\ul OUT_REPORT_EXIT_KEYBOARD\tab \tab 0xEF
\par }{\f1\fs20 \tab -exit keyboard mode (switch to flasher mode)
\par \tab -length: 2
\par \tab -meaning:\tab a) timeout in milliseconds between switching off the device and starting it in flasher mode (timeout=0-65535)
\par \tab \tab \tab b) byte 0: timeout & 0xff
\par \tab \tab \tab c) byte 1: (timeout >> 8) & 0xff
\par 
\par }{\f1\fs20\ul OUT_SET_SNOOZE_TIME\tab \tab \tab 0xF8
\par }{\f1\fs20 \tab -set's the timer value (this time is between switching off the device and witching it on in the new mode after the }{\i\f1\fs20 OUT_REPORT_EXIT_KEYBOARD }{\f1\fs20 message)
\par \tab -length:2
\par \tab NOTE: this is not used anymore - use the snoozetime from }{\i\f1\fs20 OUT_REPORT_EXIT_KEYBOARD }{\f1\fs20 and }{\i\f1\fs20 OUT_REPORT_EXIT_FLASHER }{\f1\fs20 instead!
\par 
\par }{\f1\fs20\ul IN_REPORT_EXT_EE_DATA\tab \tab \tab 0x31
\par }{\f1\fs20 \tab -as response for  OUT_REPORT_EXT_EE_READ and OUT_REPORT_EXT_EE_WRITE (check those messages for response description)
\par 
\par }{\f1\fs20\ul OUT_REPORT_EXT_EE_READ\tab \tab \tab 0xA1
\par }{\f1\fs20 \tab -read external eprom
\par \tab -length: 3 (OUTPUT)
\par \tab -meaning:\tab a) byte 0: addr & 0xff - ADDRESSLO
\par \tab \tab \tab b) byte 1: (addr >> 8) & 0xff - ADDRESSHI
\par \tab \tab \tab c) byte 3: LENGTH of the data what has to be readed(1-20)
\par \tab -response: 
\par \tab \tab - one of the ERROR_MESSAGES (*) if error occured
\par \tab \tab - if everything is ok: response type = IN_REPORT_EXT_EE_DATA}{\f1\fs20\ul 
\par }{\f1\fs20 \tab \tab \tab a) byte 0: addr & 0xff - ADDRESSLO
\par \tab \tab \tab b) byte 1: (addr >> 8) & 0xff - ADDRESSHI
\par \tab \tab \tab c) byte 2: LENGTH of the data what will be written(1-20)
\par \tab \tab \tab d) DATA (LENGTH bytes)
\par 
\par }{\f1\fs20\ul OUT_REPORT_EXT_EE_WRITE\tab \tab \tab 0xA2
\par }{\f1\fs20 \tab -write external eprom
\par \tab -length: 3+LENGTH (OUTPUT)
\par \tab -meaning:\tab a) byte 0: addr & 0xff - ADDRESSLO
\par \tab \tab \tab b) byte 1: (addr >> 8) & 0xff - ADDRESSHI
\par \tab \tab \tab c) byte 2: LENGTH of the data what will be written(1-20)
\par \tab \tab \tab d) DATA (LENGTH bytes)
\par \tab -response: 
\par \tab \tab - one of the ERROR_MESSAGES (*) if error occured
\par \tab \tab - if everything is ok: response type = IN_REPORT_EXT_EE_DATA
\par \tab \tab \tab - same format as the request: a), b), c), d)
\par \tab \tab NOTE: if the received data does not match the sent one - a memory write error occured!
\par 
\par 
\par }{\f1\fs20\ul IN_REPORT_INT_EE_DATA\tab \tab \tab 0x32
\par }{\f1\fs20 \tab -as response for  OUT_REPORT_INT_EE_READ and OUT_REPORT_INT_EE_WRITE (check those message for response description)
\par 
\par }{\f1\fs20\ul OUT_REPORT_INT_EE_READ\tab \tab \tab 0xA3
\par }{\f1\fs20 \tab -read internal eprom
\par \tab -length: 3 (OUTPUT)
\par \tab -meaning:\tab a) byte 0: addr & 0xff - ADDRESSLO
\par \tab \tab \tab b) byte 1: (addr >> 8) & 0xff - ADDRESSHI
\par \tab \tab \tab c) byte 3: LENGTH of the data what has to be readed(1-20)
\par \tab -response: 
\par \tab \tab - one of the ERROR_MESSAGES (*) if error occured
\par \tab \tab - if everything is ok: response type = IN_REPORT_INT_EE_DATA}{\f1\fs20\ul 
\par }{\f1\fs20 \tab \tab \tab a) byte 0: addr & 0xff - ADDRESSLO
\par \tab \tab \tab b) byte 1: (addr >> 8) & 0xff - ADDRESSHI
\par \tab \tab \tab c) byte 2: LENGTH of the data what will be written(1-20)
\par \tab \tab \tab d) DATA (LENGTH bytes)
\par 
\par 
\par }{\f1\fs20\ul OUT_REPORT_INT_EE_WRITE\tab \tab \tab 0xA4
\par }{\f1\fs20 \tab -write intrenal eprom
\par \tab -length: 3+LENGTH (OUTPUT)
\par \tab -meaning:\tab a) byte 0: addr & 0xff - ADDRESSLO
\par \tab \tab \tab b) byte 1: (addr >> 8) & 0xff - ADDRESSHI
\par \tab \tab \tab c) byte 2: LENGTH of the data what will be written(1-20)
\par \tab \tab \tab d) DATA (LENGTH bytes)
\par \tab -response: 
\par \tab \tab - one of the ERROR_MESSAGES (*) if error occured
\par \tab \tab - if everything is ok: response type = IN_REPORT_INT_EE_DATA
\par \tab \tab \tab - same format as the request: a), b), c), d)
\par \tab \tab NOTE: if the received data does not match the sent one - a memory write error occured!
\par 
\par }{\b\f1\fs20 USB FLASH MODE
\par }{\i\f1\fs20 
\par }{\f1\fs20\ul OUT_REPORT_EXIT_FLASHER\tab \tab \tab 0xFF}{\f1\fs20 
\par \tab -exit flasher mode (switch to keyboard mode)
\par \tab -length: 2 (OUTPUT)
\par \tab -meaning:\tab a) timeout in milliseconds between switching off the device and starting it in keyboard mode (timeout=0-65535)
\par \tab \tab \tab b) byte 0: timeout & 0xff
\par \tab \tab \tab c) byte 1: (timeout >> 8) & 0xff
\par 
\par }{\f1\fs20\ul OUT_SET_SNOOZE_TIME\tab \tab \tab 0xF8
\par }{\f1\fs20 \tab -already described for keyboard mode (not used anymore)}{\b\i\f1\fs20 
\par }{\i\f1\fs20 
\par 
\par }{\f1\fs20\ul OUT_REPORT_GET_VERSION\tab \tab \tab 0xF1}{\f1\fs20 \tab \tab \tab \tab 
\par \tab -get the software version of HID (used also to reset the messagequeue of the HID after mode switch)
\par \tab -length: 0 (OUTPUT)
\par \tab -response: ?
\par \tab 
\par }{\f1\fs20\ul OUT_REPORT_ERASE_MEMORY\tab \tab 0xF2}{\f1\fs20 \tab 
\par \tab -erase the memory (anywhere inside the 64 byte-block)
\par \tab -length: 3 (OUTPUT)
\par \tab -meaning:\tab a) byte 0: addr & 0xff - ADDRESSLO
\par \tab \tab \tab b) byte 1: (addr >> 8) & 0xff - ADDRESSHI
\par \tab \tab \tab c) byte 2: (addr >> 16) & 0xff - ADDRESSUP
\par \tab -response: 
\par \tab \tab - one of the ERROR_MESSAGES (*) if error occured
\par \tab \tab - if everything is ok: response type = OUT_REPORT_ERASE_MEMORY
\par \tab \tab \tab - same format as the request: a), b), c).
\par 
\par }{\f1\fs20\ul OUT_REPORT_READ_MEMORY\tab \tab 0xF3
\par }{\f1\fs20 \tab -read memory
\par \tab -length: 4 (OUTPUT)
\par \tab -meaning:\tab a) byte 0: addr & 0xff - ADDRESSLO
\par \tab \tab \tab b) byte 1: (addr >> 8) & 0xff - ADDRESSHI
\par \tab \tab \tab c) byte 2: (addr >> 16) & 0xff - ADDRESSUP
\par \tab \tab \tab d) byte 3: LENGTH of the data what has to be readed(1-32)
\par \tab -response: 
\par \tab \tab - one of the ERROR_MESSAGES (*) if error occured
\par \tab \tab - if everything is ok: response type = OUT_REPORT_READ_MEMORY
\par \tab \tab \tab a) byte 0: addr & 0xff - ADDRESSLO
\par \tab \tab \tab b) byte 1: (addr >> 8) & 0xff - ADDRESSHI
\par \tab \tab \tab c) byte 2: (addr >> 16) & 0xff - ADDRESSUP
\par \tab \tab \tab d) byte 3: LENGTH of the data what will be written(1-32)
\par \tab \tab \tab e) DATA (LENGTH bytes)
\par }{\f1\fs20\ul 
\par OUT_REPORT_WRITE_MEMORY\tab \tab 0xF4
\par }{\f1\fs20 \tab -write memory
\par \tab -length: 4+LENGTH (OUTPUT)
\par \tab -meaning:\tab a) byte 0: addr & 0xff - ADDRESSLO
\par \tab \tab \tab b) byte 1: (addr >> 8) & 0xff - ADDRESSHI
\par \tab \tab \tab c) byte 2: (addr >> 16) & 0xff - ADDRESSUP
\par \tab \tab \tab d) byte 3: LENGTH of the data what will be written(1-32)
\par \tab \tab \tab e) DATA (LENGTH bytes)
\par \tab -response:
\par \tab \tab - one of the ERROR_MESSAGES (*) if error occured
\par \tab \tab - if everything is ok: response type = OUT_REPORT_WRITE_MEMORY
\par \tab \tab \tab - same format as the request: a), b), c), d), e).
\par \tab \tab NOTE: if the received data does not match the sent one - a memory write error occured!
\par }{\f1\fs20\ul 
\par 
\par }{\b\f1\fs20 
\par }}